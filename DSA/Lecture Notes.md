<h1 style="text-align:center;">数据结构与算法</h1>

# 数据结构前导课

## 1、C 语言语法概述

- 什么是数据类型
  - 其实就是数据保存的容器，这个容器有多⼤
  - `sizeof` : 关键字（关键字与函数的区别：关键字是由编译器实现的，函数是由程序员实现的）
```c
#include <stdio.h>

int main() {
	printf("%zd\n", sizeof(int));
	int a;
	printf("%zd\n", sizeof a); // 只要后面不是关键字，可以不写括号
	// %zd: 可变长度，编译器根据操作系统来分配大小
	// sizeof 的返回值是 size_t，size_t 的大小跟操作系统有关，
	// 32 位系统下可能是 unsigned int，64 位系统下可能是 unsigned long long
	// %zd 能自动适配
	return 0;
}
```
- C语⾔有哪些数据类型
  - 基本数据类型
    - 1B、2B、4B、8B
  - ⾃定义数据类型
    - 程序员必须告知编译器，这个新的设计在内存上如何规划的
    - 累加组合
    - 共享组合

**关键：如何分配空间、如何操作空间、如何设计接口**

### 1.1 C 语⾔基本数据类型

- 基本数据类型：提供一套模具，供分配内存使用。
- 数据类型的核心：容量（分配空间的大小）。
- 语⾔定义的标准
  - `sizeof` 关键字的含义
  - `ISO C90` 的定义
    - char $<$ short $\le$ int $\le$ long $\le$ long long
    - char 就是 1B，long 不⼩于 4B
    - long long 就是 8B
  - `typedef` 的作⽤，如何解决跨平台的代码移植问题
```c
#include <stdint.h>

int main() {
	uint32_t a; // unsigned int
	uint64_t b; // unsigned long long
	int32_t c; // int
	int64_t d; // long long
	// 能够解决跨平台移植问题
	return 0;
}
```
- 整型数据类型
  - 整型常量
  - 容量是多少，占⽤多⼤的空间
  - 常⽤整型常量的表示
    - 进制表示
    - 字符表示
  - ASCII 码的⼏个性质
    - 可打印字符的表示
    - 不可打印字符，控制字符的表示
  - 整型变量
    - 给内存空间起⼀个可以为程序⽅便访问的名字
    - ⼤容量为⼩容量赋值的情况
      - 截断
    - ⼩容量为⼤容量赋值的情况
      - 补位：如果是有符号数，补符号位；如果是⽆符号数，补 0
```c
#include <stdio.h>
#include <stdint.h>

int main() {
	char a = 300; // overflow
	printf("%x %x\n", 300, a); // output: 12c 2c，截断
	printf("%x %x\n", a + 0x200, 0x200 + a); // output: 22c 22c
	int b = 0x12345678, bb = 0x82345678;
	long long c = bb;
	printf("%llx %llx\n", b, c); // output: 12345678 ffffffff82345678
	// 补齐，补符号位
	return 0;
}
```
- 浮点数据类型
  - 默认浮点数的空间⼤⼩
  - 浮点数的精度问题

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    char a = -2; // 补码：1111 1110
    // %hhd -> 实际贡献：-128 + 64 + 32 + 16 + 8 + 4 + 2 = -2
	// %hhu -> 实际贡献：128 + 64 + 32 + 16 + 8 + 4 + 2 = 254
	// %hhx -> 实际贡献：128 + 64 + 32 + 16 + 8 + 4 + 2 = fe
    printf("%hhd %hhu %hhx", a, a, a); // -2 65534 fe
    return 0;
}
```

### 1.2 C 语言自定义数据类型

- C 语言编译时，告知 C 语⾔编译器，你的新模具到底有多⼤（数据类型的声明，先声明再定义）。


#### 1.2.1 结构体

```c
struct abc {
	char a;
	int b;
	short c;
};
struct abc x1;
struct abc *p;
```
- `x1.a`：访问结构体成员，实际上访问结构体储存空间中对应偏移量下的内存的数据。
- `p->c`：指针指向对应空间，通过指针间接访问内存空间。
- 基础语法
  - struct 不是数据类型，而是自定义成员组合行为的说明符
  - 结构体变量和成员的访问
- 结构体的所占空间大小
  - 字节对齐的标准
  - 成员的顺序会导致结构的变化
- 位域的表示

#### 1.2.2 共用体

- 基础语法
  - union 不是数据类型，而是自定义成员组合行为的说明符
    - 整个 union 的空间是最大数据类型得大小
    - 按名字访问的一种方式
  - 为了达到底层连续区域访问的特殊行为而设计的

#### 1.2.3 枚举类型

- 一个失败的类型
  - 实际就是一个整形
  - 并没有类型限定的约束

## 2、C 语言内存管理

Clion 的工作原理及工程创建
   - 所有写的程序的目的：通过编译器生成可执行文件。
   - Clion 本事是个编辑器，它借助了编译器、调试器进行可视化的编译、调试。
   - 配置
     - 编辑能力：自动提示
     - 编译能力：指定编译器
       - GNU gcc -- MinGW (Windows 下的编译器)
       - MSVC -- Visual Studio
   - 工作原理：利用 cmake 对项目进行编译、调试等操作

### 2.1 如何表示地址这个类型

#### 2.1.1 指针类型

- 要想描述一个指针类型，需要让编译器能够解决 2 个问题，主要关注的问题：
  - 该数据类型的容量大小
  - 这个指针指向空间的操作行为，即解决 `p + 1` 和 `p + 2`，C 语言编译器如何翻译
- 常见指针行为

**常见指针定义**
```c
#include <stdio.h>

int xxx(const char *fmt, ...) {
	printf("=====");
}

int main() {
	int *p1 = (int *)0x100; 
	char *p2 = (char *)0x100;
	char p3[5]; // 字符数组
	char *p4[5]; // 字符类型指针的数组，p4: char** x1;
	char (*p5)[5] = (char (*)[5])0x100; // p5 是一个指向包含五个元素的字符数组的指针
	char p6[6][5];

	printf("the p1: %p, p1 + 1: %p\n", p1, p1 + 1); // 0x100, 0x104（指针 +1 是加上对应数据类型所占的字节）
	printf("the p2: %p, p2 + 1: %p\n", p2, p2 + 1); // 0x100, 0x101（指针 +1 是加上对应数据类型所占的字节）
	printf("the p3: %p, p3 + 1: %p\n", p3, p3 + 1); // 0x???, 0x??? + 1
	printf("the p4: %p, p4 + 1: %p\n", p4, p4 + 1); // 0x???, 0x??? + 8（64 位系统下的指针大小是 8 个字节）
	printf("the p5: %p, p5 + 1: %p\n", p5, p5 + 1); // 0x100, 0x105
	printf("the p6: %p, p6 + 1: %p\n", p6, p6 + 1); // 0x???, 0x??? + 5

	int (*addr)(const char *, ...) = printf;
	addr("Hello World\n");
	addr = xxx;
	addr("Hello World\n");
	return 0;
}
```

- 函数指针

#### 2.1.2 指针类型的运算

- 获取地址和内容
  - 获取变量空间的地址：`&`
  - 获取指针指向的数据：`*`
- 指针的算术运算：
  - 指针的加、减运算
  - 指针的偏移加获取数据：`[n]`

### 2.2 数组是什么

#### 2.2.1 数组不是数据类型

- 为了表示多个同类型的连续空间，构造了⼀个数组结构语法糖（由 `int a1, a2, a3;` 到 `int a[3];`）
- 数组只提供了一种分配方法，而不提供传递方法；数组的传递只能传递首地址，而不能传递整个空间。
- 数组名的含义：
  - 实际是⼀个常量指针，仍然具备指针的运算能⼒
  - 在定义的作用域内具有特殊的 `sizeof` 效果，如 `int a[5];`，`sizeof(a)` 的结果是 `20`。
  - 数组名的地址是⾮法的，但被编译器给重定义了
- 方括号 `[]` 的语法：如 `a[2]`，以 `a` 为首地址，偏移 $2$ 个单位后对应内存地址里面的值。
- 数组⽆法约束越界的问题，这也是 C 被诟病最多的地⽅

#### 2.2.2 普通数组和字符数组的区别

- 字符串也是⼀个语法糖
  - 双引号的功劳
  - 结尾-⾃动加⼀个 `'\0'` 符号作为结束标志
- 字符数组的初始化
  - 普通逐个初始化
  - 字符串的初始化
- 遍历算法的写法
  - 普通连续空间
  - 字符连续空间

### 2.3 内存的分段管理

#### 2.3.1 一个经典的错误

```c
int main() {
	char *str = "2021";
	str[3] = '2'; // str 是一个常量字符串，不能进行修改
	printf("str = %s\n", str);
	return 0;
}
```

#### 2.3.2 内存分段管理模型和权限

![img1](img/img1.png#pic_center)

#### 2.3.3 内存个段空间分配和使用

- 保护区（不可读不可写）
- 静态区（程序编译完就存在）
  - 代码段 `.text`
  - 只读数据段 `.rodata`
  - 数据段 `.data`
    - `static` 区
    - 全局区
- 动态区
  - 堆段（生命周期由程序员控制）
  - 栈段（生命周期由操作系统或编译器控制；空间有限，有可能会出现栈溢出的情况）

数据段和代码段的生命周期是最长的，只有在程序退出时才会消失。

## 3、C 语言模块编程和多文件



# 一、数据结构概述及顺序表逻辑



# 二、顺序表的实现



# 三、单向链表的操作及实现



# 四、单向循环链表及带头指针的链表
